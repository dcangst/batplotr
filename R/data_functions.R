#' read Batscope export
#' 
#' reads the \code{xlsx} generated by the batscope export and brings it into
#' the right format.
#'
#' @param path filename
#' @param species_col_name what is the name of the column which contains the
#'  species name
#' @param quality_col_name what is the name of the column which contains the
#'  relevant quality scores
#' @param quality_threshold sequences with species assignment quality below this
#'  threshold will be discarded.
#' @param shiny_progress display more progress info for shiny
#' @family data functions
#' @export
readBatscopeXLSX <- function(path=file.choose(), 
  species_col_name="AutoClass1", 
  quality_col_name="AutoClass1Qual",
  quality_threshold=0.8,
  shiny_progress=FALSE){

  message("\n",path,"\nwird eingelesen, kann eine Weile dauern...\n")
  if(shiny_progress){incProgress(0.1, detail = ".xlsx lesen..")}
  rawdata <- openxlsx::read.xlsx(path, sheet = 1, 
    startRow = 1, colNames = TRUE, 
    skipEmptyRows = TRUE, rowNames = FALSE, 
    detectDates = FALSE, rows = NULL, cols = NULL)
  dateOrigin <- openxlsx::getDateOrigin(path)
  #str(rawdata)
  if(shiny_progress){incProgress(0.6, detail = "Qualitaetspruefung...")}

  # MODIFY DATA for use in R
  data_r <- rawdata

  # discard sequences with low quality
  dim_qual_before <- dim(rawdata)
  quality_col_nr <- which(colnames(data_r) == quality_col_name)
  data_r <- subset(data_r,data_r[,quality_col_nr]>=quality_threshold)
  dim_qual_after <- dim(data_r)
  dim_qual_diff <- dim_qual_before[1]-dim_qual_after[1]


  cat("Summary of ",quality_col_name,"\n\n",sep="")
  print(summary(rawdata[,quality_col_nr]))
  cat("\n\'Discarded ",dim_qual_diff," of ",
    dim_qual_before[1]," sequences (",
    (dim_qual_diff/dim_qual_before[1])*100,"%); ",dim_qual_after[1],
    " remaining\n",sep="")

  if(shiny_progress){incProgress(0.1, detail = "Daten formatieren...")}
  # convert data_r/time format from excel to R
  data_r$ImportDate <- openxlsx::convertToDateTime(data_r$ImportDate, 
    origin = dateOrigin)
  #fix subtle difference in POSIXct representation that messes with 
  #some functions
  data_r$ImportDate <- as.POSIXct(as.character(data_r$ImportDate)) 
  
  data_r$SurveyDate <- openxlsx::convertToDateTime(data_r$SurveyDate, 
    origin = dateOrigin)
  #fix, see above
  data_r$SurveyDate <- as.POSIXct(as.character(data_r$SurveyDate)) 
  
  data_r$recTime <- openxlsx::convertToDateTime(data_r$recTime+data_r$recDate, 
    origin = dateOrigin)
  #fix, see above
  data_r$recTime <- as.POSIXct(as.character(data_r$recTime)) 

  data_r$recDate <- openxlsx::convertToDateTime(data_r$recDate, 
    origin = dateOrigin)
  #fix, see above
  data_r$recDate <- as.POSIXct(as.character(data_r$recDate)) 

  species_col_nr <- which(names(data_r) == species_col_name)

  data_r$species <- data_r[,species_col_nr]

  return(data_r)
}

#' Summarize Batscope data_r
#' 
#' summarizes the Batscope Data by nights and bins
#'
#' @param data_r data.frame generated with \code{\link{readBatscopeXLSX}}
#' @param bin_width length of bins in min
#' @param lat vector of GPS latitudes for the stations
#'   (recycled if needed). If NULL (default) the logged GPS data will be used 
#'   (averaged for each station)
#' @param long vector of GPS longitudes for the stations
#'   (recycled if needed). If NULL (default) the logged GPS data will be used 
#'   (averaged for each station) 
#' @param progress name of the progress bar to use, see 
#'   \code{\link[plyr]{create_progress_bar}}
#' @param shiny_progress display more progress info for shiny
#' @family data functions
#' @export
sumBatscopeData <- function(
  data_r,
  bin_length=5,
  lat=NULL,
  long=NULL,
  progress="text",
  shiny_progress=FALSE
  ){
  
  # wann startet die nacht und wann endet sie. Wird nur fuer binning
  # verwendet.
  nacht_start <- 13
  nacht_ende <- 12
  if(shiny_progress){incProgress(0.1, detail = "Binning...")}
  # binning der Daten (in bin_length min Intervalle)
  n_cuts <-(24+nacht_ende-nacht_start)*(60/bin_length)+1
  cuts_list <- list()
  for(i in 1:length(unique(data_r$SurveyDate))){
    cuts_list[[i]] <- seq(unique(data_r$SurveyDate)[i]+nacht_start*60*60,
      by=paste0(bin_length," min"),length=n_cuts)
  }
  cuts <- as.POSIXct(unlist(cuts_list),origin="1970-01-01 00:00")
  data_r$bins_factor <- cut(data_r$recTime,cuts,include.lowest=TRUE,
    right=FALSE)
  
  # Zahlen der Events pro Tag, Mikrophon, species und bins
  
  if(shiny_progress){incProgress(0.2, detail = 
    "Zusammenfassung nach Tag, Project, Species und Bins...")
  } else {
    cat("Zusammenfassung nach Tag, Project, Spezies und Bins...\n")
  }

  data_binned_bySpecies <- plyr::ddply(data_r,
    .(SurveyDate,ProjectName,species,bins_factor),
    summarize,
    n_events=length(numCallsEstimated),
    sum_nCalls=sum(numCallsEstimated),
    meanT_BL=mean(temperature),
    .progress=progress)

  # Zahlen der Events pro Tag, Mikrophon, und bins (alle species)
  
  if(shiny_progress){incProgress(0.2, detail = 
    "Zusammenfassung Total aller species...")
  } else {
    cat("Zusammenfassung Total aller species...\n")
  }

  data_binned_allSpecies <- plyr::ddply(data_r,
    .(SurveyDate,ProjectName,bins_factor),
    summarize,
    n_events=length(numCallsEstimated),
    sum_nCalls=sum(numCallsEstimated),
    meanT_BL=mean(temperature),
    .progress=progress)
  
  data_binned_allSpecies$species <- factor("all")
  
  data_binned <- rbind(data_binned_bySpecies,data_binned_allSpecies)

  data_binned$bins <- as.POSIXct(data_binned$bins_factor)

  # GPS Koordinaten

  if(shiny_progress){incProgress(0.2, detail = 
    "GPS Koordinaten bearbeiten...")
  } else {
    cat("GPS Koordinaten bearbeiten...\n")
  }

  if(is.null(lat) | is.null(long)){
    gps_coords <- ddply(data_r,.(ProjectName),summarize,
      lat=mean(GPSLatitude[GPSValid=="yes"],na.rm=TRUE),
      long=mean(GPSLongitude[GPSValid=="yes"],na.rm=TRUE)
      )
    if(any(is.na(gps_coords))){
      stop("GPS Koordinaten nicht fuer alle Stationen vorhanden.")
      stop("Bitte manuell eingeben.")
    } else {
      message("Koordinaten von Batlogger verwendet.")
      print(gps_coords)
    }
  } else {
    gps_coords <- data.frame(
      ProjectName=unique(data_r$ProjectName),
      lat,
      long)
    message("Manuelle Koordinaten verwendet.")
    print(gps_coords)
  }

  data_binned <- merge(data_binned,gps_coords)

  # Sonnenauf und -untergang
  if(shiny_progress){incProgress(0.2, detail = 
    "Berechne Sonnenauf und -untergangszeiten...")
  } else {
    cat("Berechne Sonnenauf und -untergangszeiten...\n")
  }
    
  gps_matrix <- matrix(c(data_binned$long,data_binned$lat),ncol=2)
  data_binned$sunset <- sunriset(
    gps_matrix,data_binned$SurveyDate,
    direction="sunset", POSIXct.out=TRUE)[,2]

  data_binned$sunrise <- sunriset(
    gps_matrix,data_binned$SurveyDate+24*60*60,
    direction="sunrise", POSIXct.out=TRUE)[,2]

  data_binned$ProjectName <- factor(data_binned$ProjectName)
  data_binned$species <- factor(data_binned$species)

  data_binned$bin_length <- bin_length
  return(data_binned)
}